// struct Vector2{
//     float x;
//     float y;
// }

// struct Figure{
//     Vector2 position;
//     float rotation;
//     float size;
//     string name;
// }




// Figure getFigure(float x, float y, float rotation, float size, string name)
// {
//     return { {x,y}, rotation, size, name };
// }

// Figure test_figure = getFigure(1.0, 2.0, 3.0, 4.0, "Chris");

// string test_name=getFigure(1.0, 2.0, 3.0, 4.0, "Chris").name;
// float test_x=(getFigure(1,2,3,4,"Andreas").position).x;


// int big_math=1+2*3/4-5+6*7/8-9+10*11/12-13+14*15/16-17+18*19/20-21+22*23/24-25+26*27/28-29+30*31/32-33+34*35/36-37+38*39/40-41+42*43/44-45+46*47/48-49+50*51/52-53+54*55/56-57+58*59/60-61+62*63/64-65+66*67/68-69+70*71/72-73+74*75/76-77+78*79/80-81+82*83/84-85+86*87/88-89+90*91/92-93+94*95/96-97+98*99/100-101+102*103/104-105+106*107/108-109+110*111/112-113+114*115/116-117+118*119/120-121+122*123/124-125+126*127/128-129+130*131/132-133+134*135/136-137+138*139/140-141+142*143/144-145+146*147/148-149+150*151/152-153+154*155/156-157+158*159/160-161+162*163/164-165+166*167/168-169+170*171/172-173+174*175/176-177+178*179/180-181+182*183/184-185+186*187/188-189+190*191/192-193+194*195/196-197+198*199/200-201+202*203/204-205+206*207/208-209+210*211/212-213+214*215/216-217+218*219/220-221+222*223/224-225+226*227/228-229+230*231/232-233+234*235/236-237+238*239/240-241+242*243/244-245+246*247/248-249+250;
// int big_math_parenthesis=(1+2)*(3/4)-(5+6)*(7/8)-(9+10)*(11/12)-(13+14)*(15/16)-(17+18)*(19/20)-(21+22)*(23/24)-(25+26)*(27/28)-(29+30)*(31/32)-(33+34)*(35/36)-(37+38)*(39/40)-(41+42)*(43/44)-(45+46)*(47/48)-(49+50)*(51/52)-(53+54)*(55/56)-(57+58)*(59/60)-(61+62)*(63/64)-(65+66)*(67/68)-(69+70)*(71/72)-(73+74)*(75/76)-(77+78)*(79/80)-(81+82)*(83/84)-(85+86)*(87/88)-(89+90)*(91/92)-(93+94)*(95/96)-(97+98)*(99/100)-(101+102)*(103/104)-(105+106)*(107/108)-(109+110)*(111/112)-(113+114)*(115/116)-(117+118)*(119/120)-(121+122)*(123/124)-(125+126)*(127/128)-(129+130)*(131/132)-(133+134)*(135/136)-(137+138)*(139/140)-(141+142)*(143/144)-(145+146)*(147/148)-(149+150)*(151/152)-(153+154)*(155/156)-(157+158)*(159/160)-(161+162)*(163/164)-(165+166)*(167/168)-(169+170)*(171/172)-(173+174)*(175/176)-(177+178)*(179/180)-(181+182)*(183/184)-(185+186)*(187/188)-(189+190)*(191/192)-(193+194)*(195/196)-(197+198)*(199/200)-(201+202)*(203/204)-(205+206)*(207/208)-(209+210)*(211/212)-(213+214)*(215/216)-(217+218)*(219/220)-(221+222)*(223/224)-(225+226)*(227/228)-(229+230)*(231/232)-(233+234)*(235/236)-(237+238)*(239/240)-(241+242)*(243/244)-(245+246)*(247/248)-(1*(2/3)-4*(5/6)-7*(8/9)-10*(11/12)-13*(14/15)-16*(17/18)-19*(20/21)-22*(23/24)-25*(26/27)-28*(29/30)-31*(32/33)-34*(35/36)-37*(38/39)-40*(41/42)-43*(44/45)-46*(47/48)-49*(50/51)-52*(53/54)-55*(56/57)-58*(59/60)-61*(62/63)-64*(65/66)-67*(68/69)-70*(71/72)-73*(74/75)-76*(77/78)-79*(80/81)-82*(83/84)-85*(86/87)-88*(89/90)-91*(92/93)-94*(95/96)-97*(98/99)-100*(101/102)-103*(104/105)-106*(107/108)-109*(110/111)-112*(113/114)-115*(116/117)-118*(119/120)-121*(122/123)-124*(125/126)-127*(128/129)-130*(131/132)-133*(134/135)-136*(137/138)-139*(140/141)-142*(143/144)-145*(146/147)-148*(149/150)-151*(152/153)-154*(155/156)-157*(158/159)-160*(161/162)-163*(164/165)-166*(167/168)-169*(170/171)-172*(173/174)-175*(176/177)-178*(179/180)-181*(182/183)-184*(185/186)-187*(188/189)-190*(191/192)-193*(194/195)-196*(197/198)-199*(200/201)-202*(203/204)-205*(206/207)-208*(209/210)-211*(212/213)-214*(215/216)-217*(218/219)-220*(221/222)-223*(224/225)-226*(227/228)-229*(230/231)-232*(233/234)-235*(236/237)-238*(239/240)-241*(242/243)-244*(245/246)-247*(248/249)-250);

// int getValue1()
// {
//     return 1;
// }

// int getValue2()
// {
//     return 2;
// }

// int thisShouldBeOptimizedOut()
// {
//     return getValue1() + getValue2();
// }


// int update()
// {
//     Vector2 position={0.0,0.0};
//     Figure figure = {position,0.0,1.0, "Chris"};
//     figure={position,0.0,1.0, "Chris"};

//     if(figure.name!="Andreas")
//         return 0;

//     int test=1;
//     if(false)
//         test=thisShouldBeOptimizedOut();

//     if(true)
//         return 1;
//     else
//         return thisShouldBeOptimizedOut();
// }


// int wonga=0;

// update();


// int fa(int a, Vector2[] b)
// {
//     return a;
// }

// Vector2[] array5={ {1.0,2.0}, {3.0,4.0}, {5.0,6.0}, {7.0,8.0}, {9.0,10.0} };

// int aaa=fa(fa(1,array5),array5)+fa(2,array5);

// int test_func(int a, int b, int c)
// {
//     return a+b+c;
// }

// test_func(1,2,3);


// int[] array3={1,2,3,4,5,6,7,8,9,10};
// int[] array2=int[10]; //this should move the stack pointer but not change the value
// int test2=array3[0];



// struct test {
//     int val;
//     int val2;
// }

// test[] test_array = { {1,2}, {3,4}, {5,6} };
// for(int i=0; i<#(test_array); i++)
// {

// }

// int a=1;
// int b=2;
// int[] array = int[a+b];

// int test=1;
// if(false) 
//     test=thisShouldBeOptimizedOut();

// if(true)
//     test=1;
// else
//     test=thisShouldBeOptimizedOut();





// struct foo{
//     int a;
//     int b;
// }

// struct bar{
//     foo c;
//     foo d;
// }

// bar[] e= bar[10];


// bar f = { {1,2}, {3,4}};
// bar g;



// foo[] h = { {1,2}, {3,4}, {5,6}, {7,8}, {9,10}, {11,12}, {13,14}, {15,16}, {17,18}, {19,20} };
// h[0]= {1,2};
// h[1].a=3;

// foo j = {3,4};
// h[2]= j;
// h[3]=f.c;
// h[4]=h[3];




// foo[] array_func()
// {
//     return { {1,2}, {3,4}, {5,6}, {7,8}, {9,10}, {11,12}, {13,14}, {15,16}, {17,18}, {19,20} };
// }


// foo[] k=array_func();
// int l=array_func()[0].a;
// int m=#array_func();



// string s="Hello"+0.1000+ 1;


// int ssfdsfdsafda=1+2+3+4+5+6+7+8+9+10;

// int asdfdsaf=1+2*3;
// int asdfdsaf2=1+2*3+4;



// int pa=1;
// int pb=2+pa;


// if(false)
//     pa=5;

// int pc=pa+pb;



// moveTo(1,2);





// float R=80;
// float r = 40;
// float x = 0;
// float y = 0;
// float z = 0;

// float offset_theta = 0;
// float offset_phi = 0;
// void donut(){
//     penClear();
//     penUp();
//     for (float theta = 0; theta < 370; theta += 10){
//         for (float  phi = 0; phi < 370; phi += 10)
//         {
//             x = (R + r * cos(theta+offset_theta)) * cos(phi+offset_phi);
//             y = (R + r * cos(theta+offset_theta)) * sin(phi+offset_phi);
//             z = r * sin(theta+offset_theta);

//             //Depth
//             x= x/(1+z/100);
//             y= y/(1+z/100);
//             moveTo(x, y);
//             penDown();
//         }
//         penUp();
//     }
// }

// penDown();
// while(true)
// {
//     donut();
//     offset_theta+=0.1;
//     offset_phi+=0.01;
// }



// int fib_n(int n)
// {
//     if(n<1)
//         return 0;
//     if(n==1)
//         return 1;
//     return fib_n(n-1)+fib_n(n-2);
// }


// for(int i=0;i<20;i++)
// {
//     say(fib_n(i));
//     wait(0.1);
// }


struct Vector2{
    float x;
    float y;
}


Vector2 normalize(Vector2 v)
{
    float length=sqrt(v.x*v.x+v.y*v.y);
    return {v.x/length, v.y/length};
}

Vector2 add(Vector2 a, Vector2 b)
{
    return {a.x+b.x, a.y+b.y};
}

Vector2 multiply(Vector2 a, float b)
{
    return {a.x*b, a.y*b};
}


Vector2 position={0,0};

Vector2 getInput()
{
    Vector2 input={0,0};
    if(getKey("a"))
        input.x-=1;
    if(getKey("d"))
        input.x+=1;

    if(getKey("w"))
        input.y+=1;
    if(getKey("s"))
        input.y-=1;

    return normalize(input);
}

void update()
{
    penClear();
    penUp();
    moveTo(position.x, position.y);
    penDown();


    
    Vector2 input=getInput();
    position=add(position, multiply(input, 30));
    
}

while(true)
{
    update();
}